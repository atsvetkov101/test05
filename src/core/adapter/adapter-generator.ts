import { reflect, ReflectedClass, ReflectedMethod } from 'typescript-rtti';
import 'reflect-metadata';
import { TsCompiler } from '../compiler';

export class AdapterGenerator {
  public static generate(...args: any[]){
    const params = args[0];
    const interfaceName = params[0];
    const Class = params[1];
    const iface = (reflect(Class) as unknown as ReflectedClass);
    const ifacePhrase : string = interfaceName.startsWith('I') 
      ? interfaceName.substring(1) 
      : interfaceName.substring(0);

    const generation = new Map();
    generation.set('className', `AutoGenerated${ifacePhrase}Adapter`);
    generation.set('ifaceName', `Spaceship.Operations.${interfaceName}`);

    if (!iface.methods) {
      return null;
    }
    const methods:string[] = [];
    for (const reflectedMethod of iface.methods) {
      console.log(`method:${reflectedMethod.name}`);
      const method = AdapterGenerator.generateMethod(reflectedMethod, generation.get('ifaceName'));
      methods.push(method);
    }

    const methodsString = methods.join('\n');

    const code = `
export class ${generation.get('className')} implements ${generation.get('ifaceName')}
{
obj;
constructor(obj)
{
this.obj = obj;
}
${methodsString}
}    
`;
    const jsCode = TsCompiler.compileCode(code);
    const result = TsCompiler.runCode(jsCode);
    const className = generation.get('className')
    const ResultClass = result[className];
    return ResultClass;
  }

  private static generateMethod(method: ReflectedMethod, ifaceFullName: string): string {
    const returnTypeName = AdapterGenerator.getReturnValueInfo(method);
    const inputTypeName = AdapterGenerator.getInputParameterInfo(method);
    if(method.name.startsWith('get')){
      return AdapterGenerator.generateGetMethod(method.name, ifaceFullName, returnTypeName);
    }else if(method.name.startsWith('set')){
      if (!method.parameters.length) {
        return '';  
      }
      return AdapterGenerator.generateSetMethod(method.name, ifaceFullName, inputTypeName);
    }else{
      if (inputTypeName || returnTypeName) {
        return '';
      }
      return AdapterGenerator.generateAnyMethod(method.name, ifaceFullName, 'void');
    }
  }

  private static getInputParameterInfo(method: ReflectedMethod) {
    try{
      const inputParamType = method.parameters[0].type.toString();
      const inputTypeName = inputParamType.split(' ')[1];
      return inputTypeName;
    } catch (e) {
      return null;
    }
  }

  private static getReturnValueInfo(method: ReflectedMethod) {
    try{
      const retType = method.returnType.toString();
      const returnTypeName = retType.split(' ')[1];
      return returnTypeName;
    } catch (e) {
      return null;
    }
  }

  private static generateAnyMethod(methodName: string, ifaceFullName: string, returnTypeName:string): string {
    const operation = `invoke.method.${methodName}`;
    // eslint-disable-next-line max-len
    return `public ${methodName}():${returnTypeName}\n{\n    return IoC.Resolve("${ifaceFullName}:${operation}", obj).Execute();\n}`;
  }

  private static generateGetMethod(methodName: string, ifaceFullName: string, returnTypeName:string): string {
    const property = methodName.startsWith('get') 
      ? methodName.slice(3)[0].toLowerCase() + methodName.slice(4)
      : methodName[0].toLowerCase() + methodName.slice(1);

    const operation = `${property}.get`;

    // eslint-disable-next-line max-len
    return `public ${methodName}():${returnTypeName}\n{\n    return IoC.Resolve("${ifaceFullName}:${operation}", obj);\n}`;
  }

  private static generateSetMethod(methodName: string, ifaceFullName: string, inputTypeName:string): string {
    const property = methodName.startsWith('set') 
      ? methodName.slice(3)[0].toLowerCase() + methodName.slice(4)
      : methodName[0].toLowerCase() + methodName.slice(1);

    const operation = `${property}.set`;

    // eslint-disable-next-line max-len
    return `public ${methodName}(newValue:${inputTypeName})\n{\n    return IoC.Resolve("${ifaceFullName}:${operation}", obj, newValue).Execute();\n}`;
  }
}